<?php

/**
 * countViews
 *
 * Parse the question_views.log file to count question views, excluding multiple views at the same question from the same ip.
 * To save memory during the parsing, i parse the file more than one time, looking at one question_id per time.
 * This way I can save memory as I need to mantain just a single ip array at a time, but makes the process longer.
 */

class countViewsTask extends sfBaseTask
{
  protected function configure()
  {
    $this->addOptions(array(
      new sfCommandOption('application', null, sfCommandOption::PARAMETER_REQUIRED, 'The application name'),
      new sfCommandOption('env', null, sfCommandOption::PARAMETER_REQUIRED, 'The environment', 'dev'),
      new sfCommandOption('connection', null, sfCommandOption::PARAMETER_REQUIRED, 'The connection name', 'doctrine'),
    ));

    $this->namespace        = 'quark';
    $this->name             = 'countViews';
    $this->briefDescription = 'Parse the question_views.log file to count question page views.';
    $this->detailedDescription = <<<EOF
The [countViews|INFO] task parse the question_views.log file and add the correct views counting into the database. It should run with cron every 30 minutes.
Call it with:

  [php symfony countViews|INFO]
EOF;
  }

  protected function execute($arguments = array(), $options = array())
  {
    // initialize the database connection
    $databaseManager = new sfDatabaseManager($this->configuration);
    $connection = $databaseManager->getDatabase($options['connection'])->getConnection();

    // Copy log file and flush the old one
    copy (sfConfig::get('sf_log_dir').'/question_views.log', sfConfig::get('sf_log_dir').'/question_views_counting.log');
    unlink(sfConfig::get('sf_log_dir').'/question_views.log');

    // Read first line
    $handler = @fopen(sfConfig::get('sf_log_dir').'/question_views_counting.log', "r");
    if ($handler)
    {
      // Create an array to store the qid already processed
      $ids = array();

      // Read until the end
      while (($buffer = fgets($handler, 4096)) !== false)
      {
        // Subhandler point to the line following the mainhandler
        $subhandler = @fopen(sfConfig::get('sf_log_dir').'/question_views_counting.log', "r");
        $cur = ftell($handler);
        fseek($subhandler, $cur);

        // Reset the counter
        $counter = 1;
        
        // Get the question id
        $view = explode(" ", $buffer);
        $qid = $view[0];

        // Start populating the ip array
        $ips = array();
        $ips[] = $view[1];

        // Skip the entire operation if the qid is already processed, otherwise save it into the ids array
        if (!in_array($view[0], $ids))
        {
          $ids[] = $view[0];          

          if ($subhandler)
          {
            // Read until the end, starting from +1. Done for every line of the mainhandler
            while (($subbuffer = fgets($subhandler, 4096)) !== false)
            {
              $view = explode(" ", $subbuffer);

              // Look only for the id in analysis and
              // Avoid double counting from the same ip
              if (($view[0] == $qid) && (!in_array($view[1], $ips)))
              {
                $counter ++;
                $ips[] = $view[1];
              }
            }
          }
          fclose($subhandler);

          // Output results and save into the database the new view count.
          //print "\n Question id=".$qid." has this number of entries: ".$counter. " generated by the following ips: \n";
          //print_r($ips);
          $q = Doctrine_Query::create()
            ->update('Question q')
            ->set('q.views','q.views + ?', $counter)
            ->where('q.id = ?',$qid)
            ->execute();
        }
      }
      fclose($handler);
    }
    
    // Remove temporary file
    unlink(sfConfig::get('sf_log_dir').'/question_views_counting.log');
  }
}
